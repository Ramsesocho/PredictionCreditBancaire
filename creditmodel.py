# -*- coding: utf-8 -*-
"""CreditModel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XYx-3GaUmW0cptjxzdPZYkJl4pcvcUlK
"""

# import les packages

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pickle

"""#1- Collecte,Nettoyage,Traitement Des Données


"""

#Lecture de la base de données
df=pd.read_csv('/content/train_u6lujuX_CVtuZ9i.csv')
df

#examiner la base de données
pd.set_option('display.max_rows',df.shape[0]+1)

df

# Affichons les informations de base sur le dataset tels que les valeurs manquantes, les types de données ...
df.info()

df.isnull().sum().sort_values(ascending=False)

# Remplir les valeurs manquantes
df['Credit_History'].fillna(df['Credit_History'].mode()[0], inplace=True)
df['Self_Employed'].fillna(df['Self_Employed'].mode()[0], inplace=True)
df['LoanAmount'].fillna(df['LoanAmount'].median(), inplace=True)
df['Dependents'].fillna(df['Dependents'].mode()[0], inplace=True)
df['Loan_Amount_Term'].fillna(df['Loan_Amount_Term'].mode()[0], inplace=True)
df['Gender'].fillna(df['Gender'].mode()[0], inplace=True)
df['Married'].fillna(df['Married'].mode()[0], inplace=True)

df.isnull().sum()

df.describe()

df.describe(include='O')

# Conversion des variables catégorielles en variables numériques
df['Gender'] = df['Gender'].map({'Male': 1, 'Female': 0})
df['Married'] = df['Married'].map({'Yes': 1, 'No': 0})
df['Education'] = df['Education'].map({'Graduate': 1, 'Not Graduate': 0})
df['Self_Employed'] = df['Self_Employed'].map({'Yes': 1, 'No': 0})
df['Property_Area'] = df['Property_Area'].map({'Urban': 2, 'Semiurban': 1, 'Rural': 0})
df['Loan_Status'] = df['Loan_Status'].map({'Y': 1, 'N': 0})

# Pour la variable 'Dependents', nous pouvons gérer les valeurs comme suit :
df['Dependents'] = df['Dependents'].replace('3+', 3).astype(int)

df.head()

df.dtypes

df['Education'].value_counts()

"""#2- Analyse Exploratoire"""

# Analyse de la varible target
df['Loan_Status'].value_counts()

import matplotlib.pyplot as plt

# Répartition de la variable cible
plt.figure(figsize=(8, 6))
df['Loan_Status'].value_counts().plot(kind='bar', color=['green', 'red'])
plt.xlabel('Loan Status')
plt.ylabel('Count')
plt.title('Répartition des statuts de prêt')
plt.show()

import seaborn as sns

# Relation entre le statut du prêt et l'historique de crédit
plt.figure(figsize=(8, 6))
sns.countplot(data=df, x='Credit_History', hue='Loan_Status')
plt.xlabel('Credit History')
plt.ylabel('Count')
plt.title('Répartition des statuts de prêt selon l\'historique de crédit')
plt.show()

counts = [df['Loan_Status'].value_counts()[0], df['Loan_Status'].value_counts()[1]]
yes = counts[0] / len(df['Loan_Status'])
no = counts[1] / len(df['Loan_Status'])

print(f'le pourcentage des credits accordés est : {yes:.2%}')
print(f'le pourcentage des credits non accordés est : {no:.2%}')

plt.figure(figsize=(8, 6))
plt.bar(['Crédits accordés', 'Crédits non accordés'], counts, color=['orange', 'blue'])
plt.xlabel('Catégorie')
plt.ylabel('Nombre')
plt.title('Répartition des crédits accordés et non accordés')
plt.show()

# Sexe

grid = sns.FacetGrid(df, col='Loan_Status', height=3.2, aspect=1.6)
grid.map(sns.countplot, 'Gender')

plt.show()

from sklearn.model_selection import train_test_split

# Séparation des features et de la cible
X = df.drop(columns=['Loan_ID', 'Loan_Status'])
y = df['Loan_Status']

# Division des données
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

print('X_train taille :', X_train.shape)
print('X_test taille :', X_test.shape)
print('y_train taille :', y_train.shape)
print('y_test taille :', y_test.shape)

# Je souhaite appliquer 3 modeles , evaluer et choisir le meilleur RandomForestClassifier Logistic Regression,KNN,DecisionTree
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

models={
    'RandomForestClassifier':RandomForestClassifier(random_state=42),
    'LogisticRegression':LogisticRegression(random_state=42),
    'KNeighborsClassifier':KNeighborsClassifier(),
    'DecisionTreeClassifier':DecisionTreeClassifier(max_depth=1,random_state=42)
}

#La fonction de la precision

def accu(y_true,y_pred,retu=False):
  acc=accuracy_score(y_true,y_pred),
  Class=classification_report(y_test, y_pred),
  Conf=confusion_matrix(y_test, y_pred)
  if retu:
    return acc,Class,Conf
  else:
    print(f'la precision du modele est  {acc}'),
    print(f'Classification Report est  {Class}'),
    print(f'Confusion Matrix  est {Conf}')


#la fonction d'application des modeles

def train_test_eval(models,X_train,y_train,X_test,y_test):
  for name,model in models.items():
    print(name,':')
    model.fit(X_train,y_train)
    accu(y_test,model.predict(X_test))
    print('-'*30)

train_test_eval(models,X_train,y_train,X_test,y_test)

feature_selection=df[['Credit_History','Married','CoapplicantIncome']]

feature_selection.head()

from sklearn.model_selection import train_test_split

# Séparation des features et de la cible
X = feature_selection
y = df['Loan_Status']

# Division des données
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

print('X_train taille :', X_train.shape)
print('X_test taille :', X_test.shape)
print('y_train taille :', y_train.shape)
print('y_test taille :', y_test.shape)

#Appliquer la regression logistique sur notre base de données
Classifier=LogisticRegression()
Classifier.fit(X_train, y_train)

# Prédictions sur le test set
y_pred = Classifier.predict(X_test)

y_pred

accuracy = Classifier.score(X_test, y_test)
print(f"Accuracy du modele: {accuracy:.2f}")

def predict_loan_status(credit_history, married, coapplicant_income):
  input_data = pd.DataFrame({
        'Credit_History': [credit_history],
        'Married': [married],
        'CoapplicantIncome': [coapplicant_income]
    })
  # Faire la prédiction
  prediction = Classifier.predict(input_data)
   # Convertir la prédiction en texte
  if prediction[0] == 1:
      return 'Accordé'
  else:
      return 'Non Accordé'

result = predict_loan_status(0, 1, 5000)
print(f"Le prêt est : {result}")

#Enregistrer le modele
pickle.dump(Classifier,open('model.pkl','wb'))